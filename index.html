<!-- Happy Birthday, Alex! I hope you enjoy your present <3 Gavin -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover">
<meta name="theme-color" content="#000000">

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="CatGame">

<link rel="manifest" href="manifest.webmanifest">
<link rel="apple-touch-icon" href="icons/apple-touch-icon.png">
<meta charset="UTF-8" />
<title>Cat Runner (DOM Sprites + Pixel Perfect)</title>

<style>
  html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#05050a; color:#fff; font-family: ui-monospace, Consolas, monospace; }
  #wrap { height:100vh; box-sizing:border-box; display:flex; justify-content:center; align-items:flex-start; padding:14px 14px calc(190px + env(safe-area-inset-bottom)); }

  #frame{
    position: relative;
    width: 980px;
    height: 380px;
    border-radius: 14px;
    box-shadow: 0 10px 30px rgba(0,0,0,.6);
    overflow: hidden;
    background: radial-gradient(1200px 420px at 30% 20%, #141a44 0%, #070714 55%, #04040a 100%);
  }

  canvas{
    position:absolute; inset:0;
    width:100%; height:100%;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
  }

  #sprites{
    position:absolute; inset:0;
    pointer-events:none;
  }

  .sprite{
    position:absolute;
    width: var(--wpx);
    height: var(--hpx);
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    transform: translateZ(0);
    transform-origin: left bottom;
    clip-path: inset(0px 0px 0px 0px); /* ALWAYS 0 cropping */
  }

  #hud { max-width: 980px; margin: 10px auto 0; padding: 0 16px; display:flex; gap:10px; flex-wrap:wrap; justify-content:space-between; align-items:center; opacity:.95;}
  .pill { padding:8px 10px; border-radius:999px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.08); }
  #cats{ text-align:center; padding:14px 16px; }
  .catsLine1, .catsLine2{ text-align:center; width:100%; }
  .catsLine1{ font-size: 16px; }
  .catsLine2{ font-size: 16px; margin-top:6px; }
  .muted { opacity: .8; }

  #resetBtn{
    position:absolute;
    top:10px; right:10px;
    z-index: 5;
    padding:8px 10px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,0.18);
    background: rgba(10,10,20,0.55);
    color:#fff;
    font-family: ui-monospace, Consolas, monospace;
    cursor:pointer;
    pointer-events:auto;
  }
  #resetBtn.armed{
    border-color: rgba(255,120,160,0.55);
    background: rgba(80,10,30,0.55);
  }

  #touchControls{ display:none; }
  @media (pointer: coarse), (max-width: 900px){
    #touchControls{ display:grid; }
  }

  .touchPad{
    flex: 1 1 100%;
    width: 100%;
    padding: 12px 12px;
    border-radius: 28px;
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.10);
    display: grid;
    gap: 12px;
    justify-items: center;
    pointer-events: auto;
  }

  .dpad{
    display: grid;
    grid-template-columns: 46px 46px 46px;
    grid-template-rows: 46px 46px;
    column-gap: 18px;
    row-gap: 12px;
    justify-content: center;
    align-content: center;
  }
  #btnUp{ grid-column: 2; grid-row: 1; }
  #btnLeft{ grid-column: 1; grid-row: 2; }
  #btnDown{ grid-column: 2; grid-row: 2; }
  #btnRight{ grid-column: 3; grid-row: 2; }

  .tbtn{
    -webkit-tap-highlight-color: transparent;
    touch-action: manipulation;
    user-select: none;
    width: 46px;
    height: 46px;
    border-radius: 999px;
    border: 2px solid rgba(255,255,255,0.22);
    background: rgba(255,255,255,0.14);
    color: #fff;
    font: inherit;
    font-size: 20px;
    display: grid;
    place-items: center;
  }

  .actionsRow{
    display:flex;
    gap: 16px;
    justify-content:center;
    margin-top: 10px;
  }

  .abtn{
    -webkit-tap-highlight-color: transparent;
    touch-action: manipulation;
    user-select: none;
    min-width: 132px;
    height: 46px;
    border-radius: 16px;
    border: 2px solid rgba(255,255,255,0.22);
    background: rgba(255,255,255,0.14);
    color:#fff;
    font: inherit;
    font-size: 15px;
  }

  @media (hover:hover) and (pointer:fine){
    .touchPad{ display:none; }
  }

  #startOverlay{
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    background: rgba(0,0,0,0.55);
    backdrop-filter: blur(2px);
    z-index: 1500;
    pointer-events: auto;
  }
  #startOverlay.hidden{ display:none; }
  #startOverlay .startInner{
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:14px;
    padding: 22px 18px;
  }
  #startOverlay .startBtn{
    width: min(240px, 70vw);
    height: 52px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.28);
    background: rgba(255,255,255,0.12);
    color: #fff;
    font: inherit;
    font-size: 16px;
    letter-spacing: 0.5px;
    cursor: pointer;
  }
  #startOverlay .startBtn:active{ transform: scale(0.98); }

  @media (max-width: 700px){
    :root{ --hudH: 300px; }
    html, body{ height:100vh; overflow:hidden; }
    #wrap{ padding: 8px; padding-bottom: calc(var(--hudH) + env(safe-area-inset-bottom)); }
    #frame{ width: min(980px, 96vw); height: calc(100vh - var(--hudH) - 24px); max-height: none; }
    #hud{
      position: fixed; left: 0; right: 0; bottom: 0;
      z-index: 5000; pointer-events: auto;
      max-width: none; margin: 0;
      padding: 10px 12px calc(14px + env(safe-area-inset-bottom));
      justify-content: center; gap: 12px;
      background: rgba(5,5,10,0.78);
      backdrop-filter: blur(6px);
    }
    .touchPad{ padding: 10px 12px; gap: 10px; border-radius: 22px; }
    .dpad{
      grid-template-columns: 60px 60px 60px;
      grid-template-rows: 60px 60px 60px;
      column-gap: 22px; row-gap: 14px;
    }
    .tbtn{ width: 60px; height: 60px; font-size: 22px; border-radius: 16px; }
    .actionsRow{ gap: 14px; margin-top: 6px; }
    .abtn{ min-width: 120px; height: 46px; font-size: 15px; border-radius: 14px; }
    .pill{ width: 100%; max-width: 980px; text-align: center; padding: 10px 14px; border-radius: 20px; }
  }

  html, body{ height:100%; margin:0; overflow:hidden; overscroll-behavior:none; }
  body{ --hudH: 230px; }
  #frame{ height: calc(100vh - var(--hudH)); max-height: calc(100vh - var(--hudH)); }
  #hud{
    position: fixed; left: 0; right: 0; bottom: 0;
    max-width: none; margin: 0;
    padding: 12px 12px calc(env(safe-area-inset-bottom) + 12px);
    display: flex; flex-direction: column; gap: 10px;
    justify-content: center; align-items: center;
    z-index: 5000; pointer-events: auto;
  }
  #touchControls{ width: 100%; display:flex; flex-direction: column; align-items: center; }
  #cats{ width: 100%; max-width: 980px; }
  #sprites, canvas{ pointer-events: none; }
  #resetBtn{ pointer-events: auto; z-index: 6000; }
</style>
</head>

<body>

<div id="wrap">
  <div id="frame">
    <canvas id="bg" width="980" height="380"></canvas>

    <div id="startOverlay" aria-label="Start screen">
      <div class="startInner">
        <button id="btnStart" class="startBtn" type="button">Start</button>
        <button id="btnEndless" class="startBtn" type="button">Endless</button>
      </div>
    </div>

    <button id="resetBtn" title="Press twice to confirm">Reset</button>
    <div id="sprites"></div>
  </div>
</div>

<div id="hud">
  <div id="touchControls" class="touchPad" aria-label="Touch controls">
    <div class="dpad" role="group" aria-label="Directional pad">
      <button class="tbtn" id="btnUp" aria-label="Jump">↑</button>
      <button class="tbtn" id="btnLeft" aria-label="Pause">←</button>
      <button class="tbtn" id="btnRight" aria-label="Dash">→</button>
      <button class="tbtn" id="btnDown" aria-label="Duck">↓</button>
    </div>
    <div class="actionsRow">
      <button class="abtn" id="btnRestart" aria-label="Restart">Restart</button>
      <button class="abtn" id="btnCats" aria-label="Switch cats">Switch cats</button>
    </div>
  </div>
  <div class="pill" id="cats">Cats: —</div>
</div>

<script>
/* =========================
   CONFIG
   ========================= */
const SPRITE_W = 16;
const SPRITE_H = 16;
const SCALE = 6;
const CAT_DRAW_W = SPRITE_W * SCALE;
const CAT_DRAW_H = SPRITE_H * SCALE;

const STORAGE_KEY = "cat_runner_dom_progress_v1";

const BASE_CATS = ["Calico","Chromic","Grey","Orange","Tabby"];
const SECRET_CAT = "Neon";
const ALL_CATS = [...BASE_CATS, SECRET_CAT];

/* KONAMI (strict FSM)
   Sequence: ↑ ↑ ↓ ↓ ← → ← → then confirm with Switch cats
*/
const KONAMI_DIRS = ["up","up","down","down","left","right","left","right"];
let konamiIndex = 0;

function konamiReset(){ konamiIndex = 0; }
function konamiFeed(token){
  // confirm step
  if(token === "cats"){
    if(konamiIndex === KONAMI_DIRS.length) onKonami();
    konamiReset();
    return;
  }

  // only arrow tokens matter; anything else resets
  if(token !== "up" && token !== "down" && token !== "left" && token !== "right"){
    konamiReset();
    return;
  }

  const expected = KONAMI_DIRS[konamiIndex];
  if(token === expected){
    konamiIndex++;
  } else {
    // strict reset; allow immediate restart if they hit up
    konamiIndex = (token === "up") ? 1 : 0;
  }
}

// Obstacles (relative from CatGame folder)
const OBSTACLE_LIBRARY = [
  { type:"overhead", url:"obstacles/air obstacles/FlyingFish.png",  w: 16, h: 10 },
  { type:"overhead", url:"obstacles/air obstacles/FlyingPizza.gif", w: 16, h: 11 },
  { type:"ground", url:"obstacles/ground obstacles/CatTower1.png", w: 14, h: 18 },
  { type:"ground", url:"obstacles/ground obstacles/CatTower2.png", w: 14, h: 18 },
  { type:"ground", url:"obstacles/ground obstacles/DogBark.gif",   w: 18, h: 12 },
].map(o => ({ ...o, wpx: Math.round(o.w * SCALE), hpx: Math.round(o.h * SCALE) }));

// Power-up
const POWERUP_YARN_URL = "power-ups/YarnBall.png";
const POWERUP_YARN_W = 12;
const POWERUP_YARN_H = 12;
const POWERUP_SCORE_BONUS = 5;

const POWERUP_SPAWN_MIN = 4.5;
const POWERUP_SPAWN_MAX = 8.5;
const POWERUP_MAX_ACTIVE = 1;
const POWERUP_SPEED_MULT = 1.35;

const POWERUP_BOUNCE_AMP_MIN = 10;
const POWERUP_BOUNCE_AMP_MAX = 22;
const POWERUP_BOUNCE_FREQ_MIN = 5.0;
const POWERUP_BOUNCE_FREQ_MAX = 9.0;
const POWERUP_BOUNCE_DECAY = 0.20;

const POWERUP_MIDAIR_CHANCE = 0.45;
const POWERUP_MIDAIR_OFFSET_MIN = 60;
const POWERUP_MIDAIR_OFFSET_MAX = 130;

// Gameplay
const BASE_TARGET_SCORE = 20;
const TARGET_INCREMENT  = 15;

const BASE_SCROLL_SPEED = 400;
const BOOST_MULTIPLIER  = 2;
const SPEED_RAMP_PER_SCORE = 19;

const GRAVITY = 2050;
const JUMP_VELOCITY = 900;

const DUCK_SCALE_Y = 0.62;

// Terrain
const TERRAIN_BASE_Y = 380 * 0.80;
const TERRAIN_AMPLITUDE = 10;
const TERRAIN_WAVELENGTH = 520;
const TERRAIN_DETAIL = 0.35;
const TERRAIN_SEGMENT = 18;

// Spawns
const SPAWN_MIN = 0.85;
const SPAWN_MAX = 1.45;
const AIR_CHANCE = 0.35;

/* =========================
   DOM + CANVAS
   ========================= */
const canvas = document.getElementById("bg");
const ctx = canvas.getContext("2d");
ctx.imageSmoothingEnabled = false;

const W = canvas.width, H = canvas.height;
const spritesLayer = document.getElementById("sprites");
const catsEl = document.getElementById("cats");

const startOverlay = document.getElementById("startOverlay");
const startBtn = document.getElementById("btnStart");
const endlessBtn = document.getElementById("btnEndless");

let started = false;
let gameMode = "story"; // "story" | "endless"

function startGame(mode="story"){
  if(started) return;
  started = true;
  gameMode = mode;
  startOverlay?.classList.add("hidden");
  resetRun();
}

startBtn?.addEventListener("pointerdown", (e)=>{ e.preventDefault(); startGame("story"); }, {passive:false});
endlessBtn?.addEventListener("pointerdown", (e)=>{ e.preventDefault(); startGame("endless"); }, {passive:false});

/* =========================
   UTIL
   ========================= */
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function lerp(a,b,t){ return a + (b-a)*t; }
function smoothstep(t){ return t*t*(3-2*t); }
function rand(a,b){ return a + Math.random()*(b-a); }
function aabb(ax,ay,aw,ah, bx,by,bw,bh){
  return ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by;
}

/* =========================
   PROGRESS
   ========================= */
function loadProgress(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return { unlocked: 1, selected: 0, wins: 0, neonUnlocked: false };

    const d = JSON.parse(raw);
    const oldOrder = ["Calico","Chromic","Grey","Neon","Orange","Tabby"];
    const neonUnlocked = Boolean(d.neonUnlocked ?? false);

    const oldSelectedIdx = clamp(Number(d.selected ?? 0), 0, oldOrder.length-1);
    let selectedName = oldOrder[oldSelectedIdx] || "Calico";
    if(!neonUnlocked && selectedName === "Neon") selectedName = "Calico";

    const oldUnlocked = clamp(Number(d.unlocked ?? 1), 1, oldOrder.length);
    const baseUnlocked = Math.max(1, Math.min(BASE_CATS.length,
      oldOrder.slice(0, oldUnlocked).filter(n => n !== "Neon").length
    ));

    const unlockedNames = getUnlockedCatNames({unlocked: baseUnlocked, neonUnlocked});
    let selected = unlockedNames.indexOf(selectedName);
    if(selected < 0) selected = 0;

    return { unlocked: baseUnlocked, selected, wins: Math.max(0, Number(d.wins ?? 0)), neonUnlocked };
  } catch {
    return { unlocked: 1, selected: 0, wins: 0, neonUnlocked: false };
  }
}
function saveProgress(p){ localStorage.setItem(STORAGE_KEY, JSON.stringify(p)); }

let progress = loadProgress();

function totalCats(){ return BASE_CATS.length + (progress.neonUnlocked ? 1 : 0); }
function unlockedCount(){ return progress.unlocked + (progress.neonUnlocked ? 1 : 0); }
function getUnlockedCatNames(p=progress){
  const out = BASE_CATS.slice(0, clamp(p.unlocked, 1, BASE_CATS.length));
  if(p.neonUnlocked) out.push(SECRET_CAT);
  return out;
}
function getSelectedName(){
  const unlocked = getUnlockedCatNames();
  return unlocked[clamp(progress.selected, 0, unlocked.length-1)] || unlocked[0] || BASE_CATS[0];
}
function ensureSelectedInRange(){
  const unlocked = getUnlockedCatNames();
  if(progress.selected > unlocked.length-1){
    progress.selected = unlocked.length-1;
    saveProgress(progress);
  }
}
function onKonami(){
  if(progress.neonUnlocked) return;
  progress.neonUnlocked = true;
  saveProgress(progress);
  updateHUD();
}
function cycleCats(){
  const unlocked = getUnlockedCatNames();
  progress.selected = (progress.selected + 1) % unlocked.length;
  saveProgress(progress);
  currentSkin = getSkinByName(getSelectedName());
  updateHUD();
  if(started) resetRun();
}
function updateHUD(){
  const unlockedDisp = unlockedCount();
  const totalDisp = totalCats();
  const selectedName = getSelectedName();
  const modeStr = started ? (gameMode === "endless" ? "Endless" : "Story") : "Paused";

  catsEl.innerHTML =
    `<div class="catsLine1">Cats acquired: ${unlockedDisp}/${totalDisp} | Selected: ${selectedName}</div>` +
    `<div class="catsLine2 muted">Wins: ${progress.wins} | Mode: ${modeStr} | Secret: ↑↑↓↓←→←→ then Switch cats</div>`;
}

/* =========================
   1D NOISE
   ========================= */
class Noise1D {
  constructor(seed=1337){ this.seed = seed>>>0; this.cache = new Map(); }
  hash(x){
    let n = (x * 374761393 + this.seed * 668265263) >>> 0;
    n = (n ^ (n >>> 13)) >>> 0;
    n = (n * 1274126177) >>> 0;
    return ((n ^ (n >>> 16)) >>> 0) / 4294967296;
  }
  value(xi){
    if(this.cache.has(xi)) return this.cache.get(xi);
    const v = this.hash(xi);
    if(this.cache.size > 8000) this.cache.clear();
    this.cache.set(xi, v);
    return v;
  }
  sample(x){
    const x0 = Math.floor(x), x1 = x0+1;
    const t = smoothstep(x - x0);
    return lerp(this.value(x0), this.value(x1), t);
  }
}
const noise = new Noise1D((Date.now() & 0xffffffff) ^ 0xC0FFEE);

/* =========================
   TERRAIN
   ========================= */
class Terrain {
  constructor(){ this.scrollX = 0; }
  heightAtWorldX(wx){
    const large = (noise.sample(wx / TERRAIN_WAVELENGTH) - 0.5) * 2;
    const small = (noise.sample(wx / (TERRAIN_WAVELENGTH * 0.35)) - 0.5) * 2;
    const mix = large * (1 - TERRAIN_DETAIL) + small * TERRAIN_DETAIL;
    return TERRAIN_BASE_Y - mix * TERRAIN_AMPLITUDE;
  }
  heightAtScreenX(sx){ return this.heightAtWorldX(this.scrollX + sx); }
  update(dt, scrollSpeed){ this.scrollX += scrollSpeed * dt; }
  draw(isStatic){
    // NOTE: when not started, render STATIC (no performance.now animation)
    ctx.save();

    // background dots (static or lightly animated)
    ctx.globalAlpha = 0.20;
    const t = isStatic ? 0 : (performance.now() * 0.00012);
    for(let i=0;i<70;i++){
      const px = (i*97 + (this.scrollX*0.12)) % (W+220) - 110;
      const py = (i*53 + (Math.sin(t+i)*22)) % (H*0.65);
      ctx.fillStyle = "rgba(120,255,220,0.35)";
      ctx.fillRect(px|0, py|0, 2, 2);
    }
    ctx.restore();

    // terrain fill
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(0, H);
    for(let x=0; x<=W+TERRAIN_SEGMENT; x+=TERRAIN_SEGMENT){
      ctx.lineTo(x, this.heightAtScreenX(x));
    }
    ctx.lineTo(W, H);
    ctx.closePath();
    ctx.fillStyle = "rgba(0, 255, 200, 0.06)";
    ctx.fill();

    // outline
    ctx.beginPath();
    for(let x=0; x<=W+TERRAIN_SEGMENT; x+=TERRAIN_SEGMENT){
      const y = this.heightAtScreenX(x);
      if(x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.strokeStyle = "rgba(0, 255, 220, 0.35)";
    ctx.lineWidth = 2;
    ctx.stroke();

    // scanlines (static)
    ctx.globalAlpha = 0.08;
    for(let y=0; y<H; y+=6){
      ctx.fillStyle = (y%12===0) ? "#ffffff" : "#000000";
      ctx.fillRect(0,y,W,1);
    }
    ctx.restore();
  }
}

/* =========================
   DOM SPRITES
   ========================= */
function makeSprite(url, wpx, hpx){
  const img = document.createElement("img");
  img.className = "sprite";
  img.src = url;
  img.style.setProperty("--wpx", wpx + "px");
  img.style.setProperty("--hpx", hpx + "px");
  img.style.left = "0px";
  img.style.top = "0px";
  img.style.imageRendering = "pixelated";
  img.style.clipPath = "inset(0px 0px 0px 0px)";
  img.style.transform = "translateZ(0) scaleY(1)";
  return img;
}

class CatSkin {
  constructor(name){
    const base = `Cats/${name}/${name}`;
    this.name = name;
    this.run  = `${base}Run.gif`;
    this.idle = `${base}Idle.gif`;
    this.jump = `${base}Jump.png`;
    this.dash = `${base}Run.gif`;
  }
}

let skinsByName = {};
let currentSkin = null;
function getSkinByName(name){
  return skinsByName[name] || skinsByName[BASE_CATS[0]];
}

/* =========================
   PLAYER
   ========================= */
class Player {
  constructor(terrain, skin){
    this.terrain = terrain;
    this.skin = skin;

    this.x = (window.innerWidth <= 700 ? 6 : 32);
    this.w = CAT_DRAW_W;
    this.h = CAT_DRAW_H;

    this.y = 0;
    this.vy = 0;

    this.ducking = false;
    this.paused = false;

    this.el = makeSprite(this.skin.run, this.w, this.h);
    spritesLayer.appendChild(this.el);

    this.applyVisual(false);
  }

  groundY(){ return this.terrain.heightAtScreenX(this.x) - this.h; }

  jump(){
    if(this.paused) return;
    const gy = this.groundY();
    if(this.y >= gy - 2) this.vy = -JUMP_VELOCITY;
  }

  setDuck(d){
    if(this.paused) return;
    this.ducking = d;
  }

  togglePause(){ this.paused = !this.paused; }

  update(dt){
    const gy = this.groundY();
    if(!this.paused){
      this.vy += GRAVITY * dt;
      this.y += this.vy * dt;
    }
    if(this.y > gy){
      this.y = gy;
      this.vy = 0;
    }
  }

  state(isDashing){
    const gy = this.groundY();
    if(this.paused) return "pause";
    if(this.y < gy - 1) return "jump";
    if(this.ducking) return "duck";
    if(isDashing) return "dash";
    return "run";
  }

  applyVisual(isDashing=false){
    const st = this.state(isDashing);

    let src = this.skin.run;
    if(st === "pause") src = this.skin.idle;
    else if(st === "jump") src = this.skin.jump;
    else if(st === "duck") src = this.skin.jump;
    else if(st === "dash") src = this.skin.dash;

    if(this.el.src !== new URL(src, location.href).href) this.el.src = src;

    // NO CROPPING EVER
    this.el.style.clipPath = "inset(0px 0px 0px 0px)";

    // Duck = squish, anchored to feet (no clipping)
    const isDuck = (st === "duck" && !this.paused);
    const sY = isDuck ? DUCK_SCALE_Y : 1;

    // to keep feet planted when squishing: move sprite down by (h - h*sY)
    const gy = this.groundY();
    const baseTop = Math.round(this.y);
    const duckShift = Math.round(this.h - (this.h * sY));
    const top = isDuck ? (baseTop + duckShift) : baseTop;

    this.el.style.setProperty("--wpx", this.w + "px");
    this.el.style.setProperty("--hpx", this.h + "px");
    this.el.style.left = Math.round(this.x) + "px";
    this.el.style.top  = top + "px";
    this.el.style.transform = `translateZ(0) scaleY(${sY})`;
  }

  hitbox(){
    // hitbox shrinks when ducking
    const duckFactor = this.ducking ? DUCK_SCALE_Y : 1;
    const hbW = this.w * 0.62;
    const hbH = this.h * 0.82 * duckFactor;
    const hbX = this.x + this.w * 0.18;
    const hbY = (this.y + this.h) - hbH;
    return { x:hbX, y:hbY, w:hbW, h:hbH };
  }
}

/* =========================
   POWER-UP / OBSTACLE
   ========================= */
class PowerUp {
  constructor(url, terrain, spawnX){
    this.terrain = terrain;
    this.x = spawnX;

    this.w = Math.round(POWERUP_YARN_W * SCALE);
    this.h = Math.round(POWERUP_YARN_H * SCALE);

    this.el = makeSprite(url, this.w, this.h);
    spritesLayer.appendChild(this.el);

    this.t = 0;
    this.phase = rand(0, Math.PI * 2);
    this.amp0 = rand(POWERUP_BOUNCE_AMP_MIN, POWERUP_BOUNCE_AMP_MAX);
    this.freq = rand(POWERUP_BOUNCE_FREQ_MIN, POWERUP_BOUNCE_FREQ_MAX);

    this.midair = Math.random() < POWERUP_MIDAIR_CHANCE;
    this.midairOffset = this.midair ? rand(POWERUP_MIDAIR_OFFSET_MIN, POWERUP_MIDAIR_OFFSET_MAX) : rand(10, 22);

    this.recalcY();
    this.applyPos();
  }

  destroy(){ this.el?.remove(); }

  recalcY(){
    const gy = this.terrain.heightAtScreenX(this.x);
    const base = gy - this.h - this.midairOffset;

    const amp = Math.max(6, this.amp0 * Math.exp(-POWERUP_BOUNCE_DECAY * this.t));
    const jitter = Math.sin((this.t * 1.3) + this.phase) * 2.0;
    const bob = Math.sin((this.t * this.freq) + this.phase) * amp;

    this.y = base - bob + jitter;
  }

  applyPos(){
    this.el.style.left = Math.round(this.x) + "px";
    this.el.style.top  = Math.round(this.y) + "px";
  }

  update(dt, scrollSpeed){
    this.t += dt;
    this.x -= (scrollSpeed * POWERUP_SPEED_MULT) * dt;
    this.recalcY();
    this.applyPos();
  }

  offscreen(){ return this.x + this.w < -120; }

  hitbox(){
    const pad = 3;
    return { x:this.x+pad, y:this.y+pad, w:this.w-pad*2, h:this.h-pad*2 };
  }
}

class Obstacle {
  constructor(def, terrain, spawnX){
    this.def = def;
    this.terrain = terrain;
    this.x = spawnX;
    this.type = def.type;
    this.w = def.wpx;
    this.h = def.hpx;
    this.passed = false;

    this.el = makeSprite(def.url, this.w, this.h);
    spritesLayer.appendChild(this.el);

    this.recalcY();
    this.applyPos();
  }

  destroy(){ this.el?.remove(); }

  recalcY(){
    const gy = this.terrain.heightAtScreenX(this.x);
    if(this.type === "ground"){
      this.y = gy - this.h;
    } else {
      const clearance = 50 * (SCALE/6);
      this.y = gy - clearance - this.h;
    }
  }

  applyPos(){
    this.el.style.left = Math.round(this.x) + "px";
    this.el.style.top  = Math.round(this.y) + "px";
  }

  update(dt, scrollSpeed){
    this.x -= scrollSpeed * dt;
    this.recalcY();
    this.applyPos();
  }

  offscreen(){ return this.x + this.w < -120; }

  hitbox(){
    const pad = 6;
    return { x:this.x+pad, y:this.y+pad, w:this.w-pad*2, h:this.h-pad*2 };
  }
}

/* =========================
   GAME STATE
   ========================= */
const keys = { right:false };

let terrain = new Terrain();
let player = null;
let obstacles = [];
let powerUps = [];

let powerTimer = 0;
let powerNextIn = rand(POWERUP_SPAWN_MIN, POWERUP_SPAWN_MAX);
let spawnTimer = 0;
let spawnNextIn = rand(0.85, 1.45);

let score = 0;
let targetScore = BASE_TARGET_SCORE + progress.wins * TARGET_INCREMENT;
let gameOver = false;
let won = false;

let lastT = performance.now();

function currentScrollSpeed(){
  const base = BASE_SCROLL_SPEED + score * SPEED_RAMP_PER_SCORE;
  return base * (keys.right ? BOOST_MULTIPLIER : 1);
}

function clearSprites(){
  while(spritesLayer.firstChild) spritesLayer.removeChild(spritesLayer.firstChild);
}

function resetRun(){
  clearSprites();
  obstacles = [];
  powerUps = [];

  terrain = new Terrain();

  score = 0;
  gameOver = false;
  won = false;

  targetScore = (gameMode === "endless") ? 999999999 : (BASE_TARGET_SCORE + progress.wins * TARGET_INCREMENT);

  player = new Player(terrain, currentSkin);

  spawnTimer = 0;
  spawnNextIn = rand(SPAWN_MIN, SPAWN_MAX);

  powerTimer = 0;
  powerNextIn = rand(POWERUP_SPAWN_MIN, POWERUP_SPAWN_MAX);

  updateHUD();
}

function spawnObstacle(){
  const wantAir = Math.random() < AIR_CHANCE;
  const pool = OBSTACLE_LIBRARY.filter(o => o.type === (wantAir ? "overhead" : "ground"));
  const def = (pool.length ? pool : OBSTACLE_LIBRARY)[Math.floor(Math.random()*(pool.length ? pool.length : OBSTACLE_LIBRARY.length))];
  obstacles.push(new Obstacle(def, terrain, W + 120));
}

function drawOverlay(){
  ctx.save();
  ctx.fillStyle = "rgba(255,255,255,0.92)";
  ctx.font = "16px ui-monospace, monospace";
  ctx.fillText(`Score: ${score}`, 18, 26);
  ctx.fillText(`Target: ${gameMode==="endless" ? "∞" : targetScore}`, 18, 48);
  ctx.fillStyle = "rgba(255,255,255,0.70)";
  ctx.fillText(`Speed: ${Math.round(currentScrollSpeed())} px/s${keys.right ? " (DASH)" : ""}`, 18, 70);

  if(!started){
    ctx.fillStyle = "rgba(255,255,255,0.55)";
    ctx.fillText("Paused. Enter: ↑↑↓↓←→←→ then Switch cats.", 18, 92);
  }
  ctx.restore();
}

function loop(now){
  const dt = clamp((now - lastT)/1000, 0, 1/20);
  lastT = now;

  ctx.clearRect(0,0,W,H);

  // STATIC background until started (no motion)
  terrain.draw(!started);

  if(!started){
    drawOverlay();
    requestAnimationFrame(loop);
    return;
  }

  const frozen = player?.paused || gameOver || won;
  const spd = currentScrollSpeed();

  if(!frozen){
    terrain.update(dt, spd);
    player.update(dt);

    spawnTimer += dt;
    if(spawnTimer >= spawnNextIn){
      spawnObstacle();
      spawnTimer = 0;
      spawnNextIn = rand(SPAWN_MIN, SPAWN_MAX);
    }

    powerTimer += dt;
    if(powerTimer >= powerNextIn && powerUps.length < POWERUP_MAX_ACTIVE){
      powerUps.push(new PowerUp(POWERUP_YARN_URL, terrain, W + 160));
      powerTimer = 0;
      powerNextIn = rand(POWERUP_SPAWN_MIN, POWERUP_SPAWN_MAX);
    }
  }

  for(let i=obstacles.length-1; i>=0; i--){
    const o = obstacles[i];
    if(!frozen) o.update(dt, spd);

    if(!o.passed && o.x + o.w < player.x){
      o.passed = true;
      if(!frozen && !gameOver && !won) score += 1;
    }
    if(o.offscreen()){
      o.destroy();
      obstacles.splice(i,1);
    }
  }

  for(let i=powerUps.length-1; i>=0; i--){
    const pu = powerUps[i];
    if(!frozen) pu.update(dt, spd);

    if(pu.offscreen()){
      pu.destroy();
      powerUps.splice(i,1);
      continue;
    }

    if(!frozen && !gameOver && !won){
      const phb = pu.hitbox();
      const hb  = player.hitbox();
      if(aabb(hb.x,hb.y,hb.w,hb.h, phb.x,phb.y,phb.w,phb.h)){
        score += POWERUP_SCORE_BONUS;
        pu.destroy();
        powerUps.splice(i,1);
      }
    }
  }

  if(!frozen && !gameOver && !won){
    const p = player.hitbox();
    for(const o of obstacles){
      const hb = o.hitbox();
      if(aabb(p.x,p.y,p.w,p.h, hb.x,hb.y,hb.w,hb.h)){
        gameOver = true;
        break;
      }
    }
  }

  if(gameMode === "story" && !frozen && !gameOver && !won && score >= targetScore){
    won = true;
    if(progress.unlocked < BASE_CATS.length) progress.unlocked += 1;
    progress.wins += 1;
    saveProgress(progress);
    updateHUD();
  }

  const isDashing = keys.right && !player.paused && !gameOver && !won;
  player.applyVisual(isDashing);

  drawOverlay();
  requestAnimationFrame(loop);
}

/* =========================
   INPUT
   - Always feed ONLY Konami first
   - Gameplay actions ONLY if started
   ========================= */
function handleToken(token){
  konamiFeed(token);

  if(!started) return;

  if(token === "up") player.jump();
  if(token === "down") player.setDuck(true);
  if(token === "down_up") player.setDuck(false);

  if(token === "right") keys.right = true;
  if(token === "right_up") keys.right = false;

  if(token === "left") player.togglePause();

  if(token === "restart") resetRun();

  if(token === "cats") cycleCats();
}

document.addEventListener("keydown", (e)=>{
  const code = e.code;
  if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"].includes(code)) e.preventDefault();

  if(code === "ArrowUp") handleToken("up");
  else if(code === "ArrowDown") handleToken("down");
  else if(code === "ArrowRight") handleToken("right");
  else if(code === "ArrowLeft") handleToken("left");
  else if(code === "KeyR") handleToken("restart");
}, {passive:false});

document.addEventListener("keyup", (e)=>{
  if(e.code === "ArrowDown") handleToken("down_up");
  if(e.code === "ArrowRight") handleToken("right_up");
}, {passive:false});

/* =========================
   TOUCH
   ========================= */
(function setupTouchControls(){
  const up = document.getElementById("btnUp");
  const down = document.getElementById("btnDown");
  const left = document.getElementById("btnLeft");
  const right = document.getElementById("btnRight");
  const restart = document.getElementById("btnRestart");
  const catsBtn = document.getElementById("btnCats");

  if(!up || !down || !left || !right) return;

  const hold = (el, onDown, onUp)=>{
    const stop = (e)=>{ try{ onUp(e); }catch{} };
    el.addEventListener("pointerdown", (e)=>{
      e.preventDefault();
      try{ el.setPointerCapture(e.pointerId); }catch{}
      try{ onDown(e); }catch{}
    }, {passive:false});
    el.addEventListener("pointerup", (e)=>{ e.preventDefault(); stop(e); }, {passive:false});
    el.addEventListener("pointercancel", stop);
    el.addEventListener("lostpointercapture", stop);
    el.addEventListener("pointerleave", (e)=>{ if(e.pressure === 0) stop(e); });
  };

  up.addEventListener("pointerdown", (e)=>{ e.preventDefault(); handleToken("up"); }, {passive:false});
  hold(down, ()=> handleToken("down"), ()=> handleToken("down_up"));
  hold(right, ()=> handleToken("right"), ()=> handleToken("right_up"));
  left.addEventListener("pointerdown", (e)=>{ e.preventDefault(); handleToken("left"); }, {passive:false});

  restart?.addEventListener("pointerdown", (e)=>{ e.preventDefault(); handleToken("restart"); }, {passive:false});
  catsBtn?.addEventListener("pointerdown", (e)=>{ e.preventDefault(); handleToken("cats"); }, {passive:false});
})();

/* =========================
   RESET PROGRESS (press twice)
   ========================= */
const resetBtn = document.getElementById("resetBtn");
let resetArmed = false;
let resetArmTimeout = null;

resetBtn.addEventListener("click", ()=>{
  if(!resetArmed){
    resetArmed = true;
    resetBtn.classList.add("armed");
    resetBtn.textContent = "Confirm Reset";
    clearTimeout(resetArmTimeout);
    resetArmTimeout = setTimeout(()=>{
      resetArmed = false;
      resetBtn.classList.remove("armed");
      resetBtn.textContent = "Reset";
    }, 2500);
    return;
  }
  localStorage.removeItem(STORAGE_KEY);
  location.reload();
});

/* =========================
   INIT
   ========================= */
async function init(){
  ensureSelectedInRange();
  skinsByName = Object.fromEntries(ALL_CATS.map(n => [n, new CatSkin(n)]));
  currentSkin = getSkinByName(getSelectedName());
  updateHUD();
  requestAnimationFrame(loop);
}
init();
</script>

<script>
  // Stability: remove any previously-installed service worker for this site.
  (function(){
    if(!("serviceWorker" in navigator)) return;
    navigator.serviceWorker.getRegistrations().then(regs=>{
      regs.forEach(r=>r.unregister());
    });
  })();
</script>

</body>
</html>
